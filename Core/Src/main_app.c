//$file${Src::main_app.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: tetris.qm
// File:  ${Src::main_app.c}
//
// This code has been generated by QM 7.0.2 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${Src::main_app.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


#include "main_app.h"
#include <stdio.h>
#include "app_config.h"
#include "NRF_chip.h"
#include "main.h";
#include "tetris_input_handler.h"

//DMA buffer
static __attribute__((section(".bss"))) __attribute__((aligned(4))) volatile uint32_t Sensor_dht11_dma_buffer[DHT11_MAX_EDGES];
static uint8_t gridArray[200];

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AOs::MainApp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::MainApp} ............................................................
MainApp MainApp_inst;
uint32_t  MainApp_delta_time = (MS_PER_SEC / FPS);


//${AOs::MainApp::calc_dryness_percent} ......................................
uint8_t MainApp_calc_dryness_percent(uint16_t dryness) {
    if(dryness >= MAX_DRY)
    {
        return 100;
    }

    if((uint16_t) dryness <= (uint16_t) MAX_WET)
    {
        return 0;
    }

    uint8_t percent = 0;

    percent = ((dryness - MAX_WET) * 100) / (MAX_DRY - MAX_WET);

    return percent;
}

//${AOs::MainApp::init_line_state} ...........................................
void MainApp_init_line_state(
    LineState * ls,
    int x0,
    int y0,
    int x1,
    int y1)
{
    ls->x0 = x0;
    ls->x1 = x1;
    ls->y0 = y0;
    ls->y1 = y1;
    ls->dx = abs(x1 - x0);
    ls->dy = abs(y1 - y0);
    ls->sx = (x0 < x1) ? 1 : -1;
    ls->sy = (y0 < y1) ? 1 : -1;
    ls->err = (ls->dx > ls->dy ? ls->dx : -ls->dy) / 2;
    ls->done = false;


}

//${AOs::MainApp::SM} ........................................................
QState MainApp_initial(MainApp * const me, void const * const par) {
    //${AOs::MainApp::SM::initial}
    return Q_TRAN(&MainApp_display);
}

//${AOs::MainApp::SM::display} ...............................................
QState MainApp_display(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::display}
        case Q_ENTRY_SIG: {
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::display}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->tempPollEvt);
            QTimeEvt_disarm(&me->longPressEvt);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::display::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&MainApp_display_stats);
            break;
        }
        //${AOs::MainApp::SM::display::SENSOR_DONE}
        case SENSOR_DONE_SIG: {
            //QTimeEvt_disarm(&me->tempPollEvt);
            //QTimeEvt_armX(&me->tempPollEvt,
            //              20000U,    // Fire after 10 seconds
            //              20000U);   // Then repeat every 10 seconds


            SensorEvent const *sensorEvt = (SensorEvent const *)e;
            printf("DONE SENSOR \n");

            me->currentTemp = sensorEvt->temperature;

            uint16_t tempDry = sensorEvt->dryness;
            uint8_t p = MainApp_calc_dryness_percent(tempDry);
            me->currentDryness = p;

            if (p > PLANT_DRY_THREASHOLD)
            {
                static QEvt const dry_Evt = {PLANT_DRY_SIG, 0U, 0U};
                QACTIVE_POST(AO_Main_App,&dry_Evt, me);
            }


            switch(me->currentState)
            {
                case TEMPERATURE:
                display_temp(me->currentTemp);
                break;

                case DRYNESS:

                    display_dry(p);
                break;
                default:
                        // error
                        break;

            }

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::display::POLL_SENSOR}
        case POLL_SENSOR_SIG: {
            static QEvt const ADC_Start_Evt = {START_SENSOR_SIG, 0U, 0U};
            printf("POLL SENSOR \n");
            QACTIVE_POST(AO_Sensor,&ADC_Start_Evt, me);


            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::display::BUTTON_PRESS}
        case BUTTON_PRESS_SIG: {
            QTimeEvt_disarm(&me->longPressEvt);
            QTimeEvt_armX(&me->longPressEvt, LONG_PRESS_TIME_MS / 10, 0U);
            printf("pressed btn!\n");
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::display::BUTTON_LONG}
        case BUTTON_LONG_SIG: {
            status_ = Q_TRAN(&MainApp_pump);
            break;
        }
        //${AOs::MainApp::SM::display::BUTTON_RELEASE}
        case BUTTON_RELEASE_SIG: {
            QTimeEvt_disarm(&me->longPressEvt);
            printf("released btn!\n");
            if(me->currentState == TEMPERATURE)
            {
                me->currentState = DRYNESS;
                display_dry(me->currentDryness);
            }
            else
            {
                me->currentState = TEMPERATURE;
                display_temp(me->currentTemp);
            }
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::display::START_TETRIS}
        case START_TETRIS_SIG: {
            QTimeEvt_disarm(&me->tempPollEvt);
            QTimeEvt_disarm(&me->longPressEvt);
            status_ = Q_TRAN(&MainApp_tetris);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::display::display_stats} ................................
QState MainApp_display_stats(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::display::display_stats}
        case Q_ENTRY_SIG: {
            display_temp(me->currentTemp);
            QTimeEvt_armX(&me->tempPollEvt,
                          200U,    // Fire after 10 seconds
                          2000U);   // Then repeat every 10 seconds
            printf("enter display stats: arm polling");
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::display::display_stats::PLANT_DRY}
        case PLANT_DRY_SIG: {
            status_ = Q_TRAN(&MainApp_dry_alert);
            break;
        }
        default: {
            status_ = Q_SUPER(&MainApp_display);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::display::dry_alert} ....................................
QState MainApp_dry_alert(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::display::dry_alert}
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->dryTimerEvt, DRY_TIMEOUT , 0U);
            printf("entered DRY!\n");
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::display::dry_alert}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dryTimerEvt);
            QTimeEvt_disarm(&me->tempPollEvt);
            printf("exited DRY!\n");
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::display::dry_alert::WATER_PLANT}
        case WATER_PLANT_SIG: {
            QTimeEvt_disarm(&me->dryTimerEvt);
            QTimeEvt_armX(&me->dryTimerEvt, 300U , 0U);


            status_ = Q_TRAN(&MainApp_pump);
            break;
        }
        default: {
            status_ = Q_SUPER(&MainApp_display);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::pump} ..................................................
QState MainApp_pump(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::pump}
        case Q_ENTRY_SIG: {
            printf("enter pump\n");
            QTimeEvt_disarm(&me->longPressEvt);
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);

            QTimeEvt_disarm(&me->dryTimerEvt);
            QTimeEvt_armX(&me->dryTimerEvt, 300U , 0U);

            QTimeEvt_disarm(&me->tempPollEvt);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::pump}
        case Q_EXIT_SIG: {
            printf("exit pump\n");
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
            QTimeEvt_disarm(&me->dryTimerEvt);

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::pump::BUTTON_RELEASE}
        case BUTTON_RELEASE_SIG: {
            printf("released the btm inside pump \n");
            status_ = Q_TRAN(&MainApp_display_stats);
            break;
        }
        //${AOs::MainApp::SM::pump::WATER_PLANT}
        case WATER_PLANT_SIG: {
            QTimeEvt_disarm(&me->dryTimerEvt);
            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
            status_ = Q_TRAN(&MainApp_display);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::tetris} ................................................
QState MainApp_tetris(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::tetris::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&MainApp_start_screen);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::tetris::start_screen} ..................................
QState MainApp_start_screen(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::tetris::start_screen}
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->dryTimerEvt, 400U , 0U);
            display_tetris_logo();

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::start_screen}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dryTimerEvt);

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::start_screen::WATER_PLANT}
        case WATER_PLANT_SIG: {
            clear_board();
            status_ = Q_TRAN(&MainApp_init_board);
            break;
        }
        default: {
            status_ = Q_SUPER(&MainApp_tetris);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::tetris::game} ..........................................
QState MainApp_game(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::tetris::game}
        case Q_ENTRY_SIG: {
            printf("entered tetris game\n");

            QTimeEvt_armX(&me->dryTimerEvt, MainApp_delta_time / 10U , MainApp_delta_time / 10U);


            Tetromino_ctor(&me->active_tetromino, TETRO_L);
            me->active_tetromino.y = 19;
            draw_board(&me->board_inst, &me->active_tetromino);


            accelerometer_init_polling();

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::game::WATER_PLANT}
        case WATER_PLANT_SIG: {
            int16_t tilt = read_accelerometer_tilt();
            process_tilt_move(&me->board_inst, me->active_tetromino, tilt);


            if(! (move_down(&me->board_inst, &me->active_tetromino)) )
            {
                Board_placeTetromino( &me->board_inst, &me->active_tetromino);
            }




            //
            draw_board(&me->board_inst, &me->active_tetromino);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::game::BUTTON_RELEASE}
        case BUTTON_RELEASE_SIG: {
            Tetromino_rotate(&me->active_tetromino);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&MainApp_tetris);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::tetris::init_board} ....................................
QState MainApp_init_board(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::tetris::init_board}
        case Q_ENTRY_SIG: {
            Board_init(&me->board_inst);
            printf("board initialized\n");

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::init_board::initial}
        case Q_INIT_SIG: {
            int w, h, x0, y0;

            w = me->board_inst.width  * me->board_inst.blockSize;
            h = me->board_inst.height * me->board_inst.blockSize;
            x0 = me->board_inst.pos_x;
            y0 = me->board_inst.pos_y;


            me->line_w = w;
            me->line_h = h;
            me->line_x0 = x0;
            me->line_y0 = y0;

            static QEvt const e = {DRAW_OUTLINE_SIG, 0U, 0U};
            QACTIVE_POST(AO_Main_App, &e, me);
            status_ = Q_TRAN(&MainApp_top_border);
            break;
        }
        default: {
            status_ = Q_SUPER(&MainApp_tetris);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::tetris::init_board::top_border} ........................
QState MainApp_top_border(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::tetris::init_board::top_border}
        case Q_ENTRY_SIG: {


            if(!me->board_inst.rotate_90)
            {
                MainApp_init_line_state(&me->line_state_inst, me->line_x0, me->line_y0, me->line_x0 + me->line_w - 1, me->line_y0);
            }
            else
            {
                MainApp_init_line_state(
                    &me->line_state_inst,
                    me->line_x0 + me->line_h , me->line_y0,
                    me->line_x0 + me->line_h , me->line_y0 + me->line_w );
            }
            printf("init struct \n");

            static QEvt const e = {DRAW_OUTLINE_SIG, 0U, 0U};
            QACTIVE_POST(AO_Main_App, &e, me);

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::init_board::top_border::DRAW_OUTLINE}
        case DRAW_OUTLINE_SIG: {
            draw_line_step(&me->line_state_inst);


            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::init_board::top_border::DRAW_OUTLINE_DONE}
        case DRAW_OUTLINE_DONE_SIG: {
            status_ = Q_TRAN(&MainApp_left_border);
            break;
        }
        default: {
            status_ = Q_SUPER(&MainApp_init_board);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::tetris::init_board::left_border} .......................
QState MainApp_left_border(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::tetris::init_board::left_border}
        case Q_ENTRY_SIG: {


            //MainApp_init_line_state(&me->line_state_inst,
             //                                   me->line_x0 + me->line_w - 1, me->line_y0,
            //                                    me->line_x0 + me->line_w - 1, me->line_y0 + me->line_h - 1);
            printf("init struct \n");
            if (!me->board_inst.rotate_90) {
                // original right vertical line
                MainApp_init_line_state(
                    &me->line_state_inst,
                    me->line_x0 + me->line_w , me->line_y0,
                    me->line_x0 + me->line_w , me->line_y0 + me->line_h );
            } else {
                // rotated 90° → horizontal bottom line
                MainApp_init_line_state(
                    &me->line_state_inst,
                    me->line_x0 + me->line_h , me->line_y0 + me->line_w,
                    me->line_x0 , me->line_y0 + me->line_w);
            }

            static QEvt const e = {DRAW_OUTLINE_SIG, 0U, 0U};
            QACTIVE_POST(AO_Main_App, &e, me);

            printf("line left: \n");

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::init_board::left_border::DRAW_OUTLINE}
        case DRAW_OUTLINE_SIG: {
            draw_line_step(&me->line_state_inst);


            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::init_board::left_border::DRAW_OUTLINE_DONE}
        case DRAW_OUTLINE_DONE_SIG: {
            status_ = Q_TRAN(&MainApp_btm_border);
            break;
        }
        default: {
            status_ = Q_SUPER(&MainApp_init_board);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::tetris::init_board::btm_border} ........................
QState MainApp_btm_border(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::tetris::init_board::btm_border}
        case Q_ENTRY_SIG: {


            //MainApp_init_line_state(&me->line_state_inst,
            //                                    me->line_x0 + me->line_w -1, me->line_y0 + me->line_h - 1,
            //                                    me->line_x0 , me->line_y0 + me->line_h - 1);
            if (!me->board_inst.rotate_90) {
                // original bottom horizontal line
                MainApp_init_line_state(
                    &me->line_state_inst,
                    me->line_x0 + me->line_w, me->line_y0 + me->line_h,
                    me->line_x0, me->line_y0 + me->line_h);
            } else {
                // rotated 90° → vertical left line
                MainApp_init_line_state(
                    &me->line_state_inst,
                    me->line_x0, me->line_y0 + me->line_w,
                    me->line_x0, me->line_y0
                );
            }
            static QEvt const e = {DRAW_OUTLINE_SIG, 0U, 0U};
            QACTIVE_POST(AO_Main_App, &e, me);

            printf("line btn: \n");

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::init_board::btm_border::DRAW_OUTLINE}
        case DRAW_OUTLINE_SIG: {
            draw_line_step(&me->line_state_inst);


            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::init_board::btm_border::DRAW_OUTLINE_DONE}
        case DRAW_OUTLINE_DONE_SIG: {
            status_ = Q_TRAN(&MainApp_right_border);
            break;
        }
        default: {
            status_ = Q_SUPER(&MainApp_init_board);
            break;
        }
    }
    return status_;
}

//${AOs::MainApp::SM::tetris::init_board::right_border} ......................
QState MainApp_right_border(MainApp * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::MainApp::SM::tetris::init_board::right_border}
        case Q_ENTRY_SIG: {

            if (!me->board_inst.rotate_90) {
                // original left vertical line
                MainApp_init_line_state(
                    &me->line_state_inst,
                    me->line_x0, me->line_y0 + me->line_h,
                    me->line_x0, me->line_y0
                );
            } else {
                // rotated 90° → horizontal top line
                MainApp_init_line_state(
                    &me->line_state_inst,
                    me->line_x0, me->line_y0,
                    me->line_x0 + me->line_h, me->line_y0
                );
            }

            static QEvt const e = {DRAW_OUTLINE_SIG, 0U, 0U};
            QACTIVE_POST(AO_Main_App, &e, me);


            printf("line right: \n");

            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::init_board::right_border::DRAW_OUTLINE}
        case DRAW_OUTLINE_SIG: {
            draw_line_step(&me->line_state_inst);


            status_ = Q_HANDLED();
            break;
        }
        //${AOs::MainApp::SM::tetris::init_board::right_border::DRAW_OUTLINE_DONE}
        case DRAW_OUTLINE_DONE_SIG: {
            printf("done drawing line\n");
            status_ = Q_TRAN(&MainApp_game);
            break;
        }
        default: {
            status_ = Q_SUPER(&MainApp_init_board);
            break;
        }
    }
    return status_;
}
//$enddef${AOs::MainApp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${Shared} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${Shared::AO_Main_App} .....................................................
QActive * const AO_Main_App = &MainApp_inst.super;

//${Shared::Main_App_ctor} ...................................................
void Main_App_ctor(MainApp * const me) {
    QActive_ctor(&me->super, Q_STATE_CAST(&MainApp_initial));
    QTimeEvt_ctorX(&me->tempPollEvt, &me->super, POLL_SENSOR_SIG, 0U);
    QTimeEvt_ctorX(&me->longPressEvt, &me->super, BUTTON_LONG_SIG, 0U);
    QTimeEvt_ctorX(&me->dryTimerEvt, &me->super, WATER_PLANT_SIG, 0U);
    Board_ctor(&me->board_inst, gridArray, 10, 20, 16,1, true, 3);


    me->currentTemp = 0.0f;
}

//${Shared::AO_Sensor} .......................................................
QActive * const AO_Sensor = &Sensor_inst.super;

//${Shared::Sensor_ctor} .....................................................
void Sensor_ctor(Sensor * const me) {
    QActive_ctor(&me->super, Q_STATE_CAST(&Sensor_initial));
    QTimeEvt_ctorX(&me->resetEvt, &me->super, DHT11_RESET_SIG, 0U);
    QTimeEvt_ctorX(&me->dht11StartEvt, &me->super, DHT11_START_SIG, 0U);
    me->dma_buffer = Sensor_dht11_dma_buffer;
    me->dma_index = 0;

}

//${Shared::AO_RFButton} .....................................................
QActive * const AO_RFButton = &RFButton_inst.super;

//${Shared::RFButton_ctor} ...................................................
void RFButton_ctor(RFButton * const me) {
    QActive_ctor(&me->super, Q_STATE_CAST(&RFButton_initial));

}
//$enddef${Shared} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



