<?xml version="1.0" encoding="UTF-8"?>
<model version="7.0.2" links="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.state-machine.com/qm/qm7.xsd">
 <documentation>Dining Philosopher Problem example</documentation>
 <!--${qpc}-->
 <framework name="qpc"/>
 <!--${Shared}-->
 <package name="Shared" stereotype="0x01">
  <!--${Shared::AO_Main_App}-->
  <attribute name="AO_Main_App" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;MainApp_inst.super;</code>
  </attribute>
  <!--${Shared::Main_App_ctor}-->
  <operation name="Main_App_ctor" type="void" visibility="0x00" properties="0x00">
   <!--${Shared::Main_App_ctor::me}-->
   <parameter name="me" type="MainApp * const"/>
   <code>QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;MainApp_initial));
QTimeEvt_ctorX(&amp;me-&gt;tempPollEvt, &amp;me-&gt;super, POLL_SENSOR_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;longPressEvt, &amp;me-&gt;super, BUTTON_LONG_SIG, 0U);
me-&gt;currentTemp = 0.0f;</code>
  </operation>
  <!--${Shared::AO_Sensor}-->
  <attribute name="AO_Sensor" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;Sensor_inst.super;</code>
  </attribute>
  <!--${Shared::Sensor_ctor}-->
  <operation name="Sensor_ctor" type="void" visibility="0x00" properties="0x00">
   <!--${Shared::Sensor_ctor::me}-->
   <parameter name="me" type="Sensor * const"/>
   <code>QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Sensor_initial));

me-&gt;dma_buffer = Sensor_dht11_dma_buffer;
me-&gt;dma_index = 0;
</code>
  </operation>
  <!--${Shared::AO_RFButton}-->
  <attribute name="AO_RFButton" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;RFButton_inst.super;</code>
  </attribute>
  <!--${Shared::RFButton_ctor}-->
  <operation name="RFButton_ctor" type="void" visibility="0x00" properties="0x00">
   <!--${Shared::RFButton_ctor::me}-->
   <parameter name="me" type="RFButton * const"/>
   <code>QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;RFButton_initial));
</code>
  </operation>
 </package>
 <!--${AOs}-->
 <package name="AOs" stereotype="0x02">
  <!--${AOs::MainApp}-->
  <class name="MainApp" superclass="qpc::QActive">
   <!--${AOs::MainApp::inst}-->
   <attribute name="inst" type="MainApp" visibility="0x02" properties="0x01"/>
   <!--${AOs::MainApp::tempPollEvt}-->
   <attribute name="tempPollEvt" type="QTimeEvt " visibility="0x00" properties="0x00"/>
   <!--${AOs::MainApp::currentTemp}-->
   <attribute name="currentTemp" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::MainApp::currentDryness}-->
   <attribute name="currentDryness" type="uint16_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::MainApp::currentState}-->
   <attribute name="currentState" type="display_states" visibility="0x02" properties="0x00">
    <code>curr_state = &quot;t&quot;;</code>
   </attribute>
   <!--${AOs::MainApp::longPressEvt}-->
   <attribute name="longPressEvt" type="QTimeEvt" visibility="0x00" properties="0x00"/>
   <!--${AOs::MainApp::calc_dryness_percent}-->
   <operation name="calc_dryness_percent" type="uint8_t" visibility="0x02" properties="0x01">
    <!--${AOs::MainApp::calc_dryness_per~::dryness}-->
    <parameter name="dryness" type="uint16_t"/>
    <code>if(dryness &gt;= MAX_DRY)
{
    return 100;
}

if((uint16_t) dryness &lt;= (uint16_t) MAX_WET)
{
    return 0;
}

uint8_t percent = 0;

percent = ((dryness - MAX_WET) * 100) / (MAX_DRY - MAX_WET);

return percent;</code>
   </operation>
   <!--${AOs::MainApp::SM}-->
   <statechart properties="0x00">
    <!--${AOs::MainApp::SM::initial}-->
    <initial target="../1">
     <initial_glyph conn="41,6,5,0,-13,6">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <!--${AOs::MainApp::SM::display}-->
    <state name="display">
     <entry brief="arm and poll ">QTimeEvt_armX(&amp;me-&gt;tempPollEvt, 
              800U,    // Fire after 10 seconds
              800U);   // Then repeat every 10 seconds

HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);</entry>
     <!--${AOs::MainApp::SM::display::initial}-->
     <initial target="../6">
      <initial_glyph conn="49,20,5,0,-5,5">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <!--${AOs::MainApp::SM::display::SENSOR_DONE}-->
     <tran trig="SENSOR_DONE">
      <action>SensorEvent const *sensorEvt = (SensorEvent const *)e;

me-&gt;currentTemp = sensorEvt-&gt;temperature;

uint16_t tempDry = sensorEvt-&gt;dryness;

switch(me-&gt;currentState)
{
    case TEMPERATURE:
    display_temp(me-&gt;currentTemp);
    break;
    
    case DRYNESS:
        uint8_t p = MainApp_calc_dryness_percent(tempDry);
        me-&gt;currentDryness = p;
        display_dry(p);
    break;
    default:
            // error
            break;

}
</action>
      <tran_glyph conn="106,38,1,-1,-22">
       <action box="-18,-3,18,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::POLL_SENSOR}-->
     <tran trig="POLL_SENSOR">
      <action>static QEvt const ADC_Start_Evt = {START_SENSOR_SIG, 0U, 0U};
QACTIVE_POST(AO_Sensor,&amp;ADC_Start_Evt, me);
verify_rx_mode();</action>
      <tran_glyph conn="106,33,1,-1,-22">
       <action box="-17,-3,21,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::BUTTON_PRESS}-->
     <tran trig="BUTTON_PRESS">
      <action>QTimeEvt_disarm(&amp;me-&gt;longPressEvt);
QTimeEvt_armX(&amp;me-&gt;longPressEvt, LONG_PRESS_TIME_MS / 10, 0U);</action>
      <tran_glyph conn="106,57,1,-1,-22">
       <action box="-19,-2,18,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::BUTTON_LONG}-->
     <tran trig="BUTTON_LONG" target="../../2">
      <tran_glyph conn="53,99,2,0,16">
       <action box="0,0,22,4"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::BUTTON_RELEASE}-->
     <tran trig="BUTTON_RELEASE">
      <action brief="short press">QTimeEvt_disarm(&amp;me-&gt;longPressEvt);

if(me-&gt;currentState == TEMPERATURE)
{
    me-&gt;currentState = DRYNESS;
    display_dry(me-&gt;currentDryness);
}
else
{
    me-&gt;currentState = TEMPERATURE;
    display_temp(me-&gt;currentTemp);
}</action>
      <tran_glyph conn="106,68,1,-1,-23">
       <action box="-24,-4,24,7"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::display_stats}-->
     <state name="display_stats">
      <entry>display_temp(me-&gt;currentTemp);
</entry>
      <exit>QTimeEvt_disarm(&amp;me-&gt;tempPollEvt);</exit>
      <state_glyph node="14,25,41,31">
       <entry box="0,3,6,2"/>
       <exit box="0,5,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="9,12,97,87">
      <entry box="0,3,6,2"/>
     </state_glyph>
    </state>
    <!--${AOs::MainApp::SM::pump}-->
    <state name="pump">
     <entry>printf(&quot;enter pump\n&quot;);
QTimeEvt_disarm(&amp;me-&gt;longPressEvt);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);

</entry>
     <exit>printf(&quot;exit pump\n&quot;);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);</exit>
     <!--${AOs::MainApp::SM::pump::BUTTON_RELEASE}-->
     <tran trig="BUTTON_RELEASE" target="../../1/6">
      <action>printf(&quot;released the btm inside pump \n&quot;);</action>
      <tran_glyph conn="38,115,0,2,-59">
       <action box="-17,-4,15,3"/>
      </tran_glyph>
     </tran>
     <state_glyph node="24,115,34,18">
      <entry box="0,3,6,2"/>
      <exit box="0,5,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="128,134"/>
   </statechart>
  </class>
  <!--${AOs::Sensor}-->
  <class name="Sensor" superclass="qpc::QActive">
   <!--${AOs::Sensor::inst}-->
   <attribute name="inst" type="Sensor" visibility="0x02" properties="0x01"/>
   <!--${AOs::Sensor::bits[5]}-->
   <attribute name="bits[5]" type="uint8_t" visibility="0x00" properties="0x00"/>
   <!--${AOs::Sensor::bit_index}-->
   <attribute name="bit_index" type="uint8_t" visibility="0x00" properties="0x00"/>
   <!--${AOs::Sensor::byte_index}-->
   <attribute name="byte_index" type="uint8_t" visibility="0x00" properties="0x00"/>
   <!--${AOs::Sensor::reading_high}-->
   <attribute name="reading_high" type="bool" visibility="0x02" properties="0x00"/>
   <!--${AOs::Sensor::pulse_count}-->
   <attribute name="pulse_count" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::Sensor::dma_buffer}-->
   <attribute name="dma_buffer" type="volatile uint32_t*" visibility="0x02" properties="0x00"/>
   <!--${AOs::Sensor::dma_index}-->
   <attribute name="dma_index" type="uint8_t" visibility="0x02" properties="0x00">
    <code>= 0;</code>
   </attribute>
   <!--${AOs::Sensor::SM}-->
   <statechart properties="0x00">
    <!--${AOs::Sensor::SM::initial}-->
    <initial target="../1">
     <initial_glyph conn="60,16,4,0,15">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <!--${AOs::Sensor::SM::waiting}-->
    <state name="waiting">
     <!--${AOs::Sensor::SM::waiting::START_SENSOR}-->
     <tran trig="START_SENSOR" target="../../2">
      <action>
for(int i=0;i&lt;5;i++) me-&gt;bits[i]=0;
me-&gt;bit_index = 0;
me-&gt;byte_index = 0;

</action>
      <tran_glyph conn="76,62,4,0,12">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="42,31,70,31"/>
    </state>
    <!--${AOs::Sensor::SM::start_temperature}-->
    <state name="start_temperature">
     <!--${AOs::Sensor::SM::start_temperatur~::initial}-->
     <initial target="../1">
      <action>// Pull DHT11 LOW ≥18ms
DHT11_SetPinOutput();
HAL_GPIO_WritePin(DHT11_PORT, DHT11_PIN, GPIO_PIN_RESET);
Delay_ms(20);
HAL_GPIO_WritePin(DHT11_PORT, DHT11_PIN, GPIO_PIN_SET);
// Switch pin to input
DHT11_SetPinInput();
Delay_us(30);

</action>
      <initial_glyph conn="83,84,5,0,-6,11">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <!--${AOs::Sensor::SM::start_temperatur~::wait_response}-->
     <state name="wait_response">
      <entry brief="init">me-&gt;bit_index = 0;
me-&gt;byte_index = 0;
me-&gt;reading_high = false;
me-&gt;pulse_count = 0; 
memset(me-&gt;bits, 0, sizeof(me-&gt;bits));
</entry>
      <!--${AOs::Sensor::SM::start_temperatur~::wait_response::DHT11_TIMER_IC}-->
      <tran trig="DHT11_TIMER_IC">
       <action>uint32_t pulse_length = ((DHT11Evt const *)e)-&gt;pulse_length;

me-&gt;pulse_count++;

// Skip first 2 pulses (response: 80µs LOW + 80µs HIGH)
if (me-&gt;pulse_count &lt;= 2) {
    status_ = Q_HANDLED();
    break;
}

// Now process data bits
me-&gt;reading_high = !me-&gt;reading_high;

if (me-&gt;reading_high) {
    // We're measuring the HIGH pulse (data bit)
    if (pulse_length &gt; 40) {  // threshold between 0 and 1
        // logical 1 (70µs)
        me-&gt;bits[me-&gt;byte_index] |= (1 &lt;&lt; (7 - me-&gt;bit_index));
    }
    // else bit=0 by default (26-28µs)
    
    me-&gt;bit_index++;
    if (me-&gt;bit_index &gt; 7) {
        me-&gt;bit_index = 0;
        me-&gt;byte_index++;
        
        if (me-&gt;byte_index &gt;= 5) {
            // Done reading 40 bits
            //HAL_TIM_IC_Stop_IT(&amp;htim3, TIM_CHANNEL_1);
            
            // Verify checksum
            uint8_t checksum = me-&gt;bits[0] + me-&gt;bits[1] + me-&gt;bits[2] + me-&gt;bits[3];
            if (checksum == me-&gt;bits[4]) {
                // Valid data
                printf(&quot;Humidity: %u.%u%%  Temperature: %u.%u°C\n&quot;,
                       me-&gt;bits[0], me-&gt;bits[1],
                       me-&gt;bits[2], me-&gt;bits[3]);
            } else {
                printf(&quot;Checksum error! Expected: %u, Got: %u\n&quot;,
                       checksum, me-&gt;bits[4]);
            }
            
            status_ = Q_TRAN(&amp;Sensor_waiting);
            break;
        }
    }
}</action>
       <tran_glyph conn="97,105,1,-1,-10">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="53,95,44,20">
       <entry box="0,3,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="48,74,65,45"/>
    </state>
    <state_diagram size="196,261"/>
   </statechart>
  </class>
  <!--${AOs::RFButton}-->
  <class name="RFButton" superclass="qpc::QActive">
   <!--${AOs::RFButton::inst}-->
   <attribute name="inst" type="RFButton" visibility="0x02" properties="0x01"/>
   <!--${AOs::RFButton::receive_rf}-->
   <operation name="receive_rf" type="void" visibility="0x02" properties="0x01">
    <code>while(nrf24_data_available()) {
        uint8_t payload[PLD_S]; 
        nrf24_receive(payload, sizeof(payload));

        if(payload[0] == 49U)
        {
            static QEvt const nrfEvt = { BUTTON_PRESS_SIG, 0U, 0U };
            QACTIVE_POST(AO_Main_App, &amp;nrfEvt, me);
        }

        if(payload[0] == 50U)
        {
            static QEvt const rlsEvt = { BUTTON_RELEASE_SIG, 0U, 0U };
            QACTIVE_POST(AO_Main_App, &amp;rlsEvt, me);
        }
        
    }</code>
   </operation>
   <!--${AOs::RFButton::SM}-->
   <statechart properties="0x00">
    <!--${AOs::RFButton::SM::initial}-->
    <initial target="../1">
     <initial_glyph conn="49,9,5,0,-6,10">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <!--${AOs::RFButton::SM::wait}-->
    <state name="wait">
     <entry>printf(&quot;wait\n&quot;);
</entry>
     <!--${AOs::RFButton::SM::wait::NRF_IRQ}-->
     <tran trig="NRF_IRQ">
      <action brief="receive">RFButton_receive_rf();
</action>
      <tran_glyph conn="41,36,4,-1,-9">
       <action box="1,-3,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="26,19,32,17">
      <entry box="0,3,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="153,121"/>
   </statechart>
  </class>
 </package>
 <!--${Inc}-->
 <directory name="Inc">
  <!--${Inc::main_app.h}-->
  <file name="main_app.h">
   <text>#ifndef MAIN_APP_H
#define MAIN_APP_H

#include &quot;qpc.h&quot;
#include &quot;temp_sensor.h&quot;
#include &quot;display.h&quot;
#include &quot;plant_sensor.h&quot;
#include &quot;sensor.h&quot;
#include &quot;rfbutton.h&quot;


//keep track of substates
typedef enum {
    TEMPERATURE,
    DRYNESS
} display_states;

$declare${AOs::MainApp}

$declare ${Shared}
// Signals
enum MenuGameSignals {
    BUTTON_PRESS_SIG = Q_USER_SIG,
    POLL_SENSOR_SIG,
    BUTTON_SHORT_SIG,
    BUTTON_LONG_SIG,
    BUTTON_RELEASE_SIG,
    START_SENSOR_SIG,
    SENSOR_DONE_SIG,
    NRF_IRQ_SIG,
    DHT11_TIMER_IC_SIG,
    DHT11_DONE_SIG,
    MAX_SIG  
};


//events

typedef struct {
    QEvt super;       
    uint16_t dryness;      
    uint16_t temperature;     
} SensorEvent;

typedef struct {
    QEvt super;      
    uint32_t pulse_length; 
    uint8_t dummy;
} DHT11Evt;

#endif </text>
  </file>
  <!--${Inc::sensor.h}-->
  <file name="sensor.h">
   <text>#ifndef SENSOR_H
#define SENSOR_H

#include &quot;qpc.h&quot;

$declare${AOs::Sensor}


#endif </text>
  </file>
  <!--${Inc::rfbutton.h}-->
  <file name="rfbutton.h">
   <text>#ifndef RFBUTTON_H
#define RFBUTTON_H

#include &quot;qpc.h&quot;

$declare${AOs::RFButton}



#endif </text>
  </file>
 </directory>
 <!--${Src}-->
 <directory name="Src">
  <!--${Src::main_app.c}-->
  <file name="main_app.c">
   <text>

#include &quot;main_app.h&quot;
#include &lt;stdio.h&gt;
#include &quot;app_config.h&quot;
#include &quot;NRF_chip.h&quot;

//DMA buffer
static __attribute__((section(&quot;.bss&quot;))) __attribute__((aligned(4))) volatile uint32_t Sensor_dht11_dma_buffer[DHT11_MAX_EDGES];

$define${AOs::MainApp}
$define${Shared}


</text>
  </file>
  <!--${Src::sensor.c}-->
  <file name="sensor.c">
   <text>#include &quot;sensor.h&quot;
#include &lt;stdio.h&gt;
#include &quot;main_app.h&quot;
#include &quot;app_config.h&quot;
#include &quot;temp_sensor.h&quot;



extern ADC_HandleTypeDef hadc1;
//extern TIM_HandleTypeDef htim3;
//extern DMA_HandleTypeDef hdma;
//extern DMA_HandleTypeDef hdma_tim3_ch1;
$define${AOs::Sensor}



// DMA buffer must be in RAM, not flash
// Must be in RAM for DMA, do NOT use 'const'
//static __attribute__((aligned(4))) volatile uint32_t dht11_dma_buffer[DHT11_MAX_EDGES];
//static volatile uint8_t dma_index = 0;

//QActive * const AO_Sensor = &amp;Sensor_inst;</text>
  </file>
  <!--${Src::rfbutton.c}-->
  <file name="rfbutton.c">
   <text>#include &quot;rfbutton.h&quot;
#include &quot;main_app.h&quot;
#include &quot;NRF_chip.h&quot;
$define${AOs::RFButton}</text>
  </file>
 </directory>
</model>
