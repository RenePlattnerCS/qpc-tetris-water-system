<?xml version="1.0" encoding="UTF-8"?>
<model version="7.0.2" links="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.state-machine.com/qm/qm7.xsd">
 <documentation>Self watering plant sysem</documentation>
 <!--${qpc}-->
 <framework name="qpc"/>
 <!--${Shared}-->
 <package name="Shared" stereotype="0x01">
  <!--${Shared::AO_Main_App}-->
  <attribute name="AO_Main_App" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;MainApp_inst.super;</code>
  </attribute>
  <!--${Shared::Main_App_ctor}-->
  <operation name="Main_App_ctor" type="void" visibility="0x00" properties="0x00">
   <!--${Shared::Main_App_ctor::me}-->
   <parameter name="me" type="MainApp * const"/>
   <code>QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;MainApp_initial));
QTimeEvt_ctorX(&amp;me-&gt;tempPollEvt, &amp;me-&gt;super, POLL_SENSOR_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;longPressEvt, &amp;me-&gt;super, BUTTON_LONG_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;dryTimerEvt, &amp;me-&gt;super, WATER_PLANT_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;tickEvt, &amp;me-&gt;super, TICK_SIG, 0U);
Board_ctor(&amp;me-&gt;board_inst, gridArray, 10, 20, 16,1, true, 3);


me-&gt;currentTemp = 0.0f;</code>
  </operation>
  <!--${Shared::AO_Sensor}-->
  <attribute name="AO_Sensor" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;Sensor_inst.super;</code>
  </attribute>
  <!--${Shared::Sensor_ctor}-->
  <operation name="Sensor_ctor" type="void" visibility="0x00" properties="0x00">
   <!--${Shared::Sensor_ctor::me}-->
   <parameter name="me" type="Sensor * const"/>
   <code>QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Sensor_initial));
QTimeEvt_ctorX(&amp;me-&gt;resetEvt, &amp;me-&gt;super, DHT11_RESET_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;dht11StartEvt, &amp;me-&gt;super, DHT11_START_SIG, 0U);
me-&gt;dma_buffer = Sensor_dht11_dma_buffer;
me-&gt;dma_index = 0;
</code>
  </operation>
  <!--${Shared::AO_RFButton}-->
  <attribute name="AO_RFButton" type="QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;RFButton_inst.super;</code>
  </attribute>
  <!--${Shared::RFButton_ctor}-->
  <operation name="RFButton_ctor" type="void" visibility="0x00" properties="0x00">
   <!--${Shared::RFButton_ctor::me}-->
   <parameter name="me" type="RFButton * const"/>
   <code>QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;RFButton_initial));
</code>
  </operation>
 </package>
 <!--${AOs}-->
 <package name="AOs" stereotype="0x02">
  <!--${AOs::MainApp}-->
  <class name="MainApp" superclass="qpc::QActive">
   <!--${AOs::MainApp::inst}-->
   <attribute name="inst" type="MainApp" visibility="0x02" properties="0x01"/>
   <!--${AOs::MainApp::tempPollEvt}-->
   <attribute name="tempPollEvt" type="QTimeEvt " visibility="0x00" properties="0x00"/>
   <!--${AOs::MainApp::currentTemp}-->
   <attribute name="currentTemp" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::MainApp::currentDryness}-->
   <attribute name="currentDryness" type="uint16_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::MainApp::currentState}-->
   <attribute name="currentState" type="display_states" visibility="0x02" properties="0x00">
    <code>curr_state = &quot;t&quot;;</code>
   </attribute>
   <!--${AOs::MainApp::longPressEvt}-->
   <attribute name="longPressEvt" type="QTimeEvt" visibility="0x00" properties="0x00"/>
   <!--${AOs::MainApp::dryTimerEvt}-->
   <attribute name="dryTimerEvt" type="QTimeEvt" visibility="0x00" properties="0x00"/>
   <!--${AOs::MainApp::line_state_inst}-->
   <attribute name="line_state_inst" type="LineState" visibility="0x02" properties="0x00"/>
   <!--${AOs::MainApp::board_inst}-->
   <attribute name="board_inst" type="Board" visibility="0x02" properties="0x00"/>
   <!--${AOs::MainApp::tickEvt}-->
   <attribute name="tickEvt" type="QTimeEvt " visibility="0x00" properties="0x00"/>
   <!--${AOs::MainApp::line_w }-->
   <attribute name="line_w " type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::MainApp::line_h }-->
   <attribute name="line_h " type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::MainApp::line_x0 }-->
   <attribute name="line_x0 " type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::MainApp::line_y0 }-->
   <attribute name="line_y0 " type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::MainApp::calc_dryness_percent}-->
   <operation name="calc_dryness_percent" type="uint8_t" visibility="0x02" properties="0x01">
    <!--${AOs::MainApp::calc_dryness_per~::dryness}-->
    <parameter name="dryness" type="uint16_t"/>
    <code>if(dryness &gt;= MAX_DRY)
{
    return 100;
}

if((uint16_t) dryness &lt;= (uint16_t) MAX_WET)
{
    return 0;
}

uint8_t percent = 0;

percent = ((dryness - MAX_WET) * 100) / (MAX_DRY - MAX_WET);

return percent;</code>
   </operation>
   <!--${AOs::MainApp::init_line_state}-->
   <operation name="init_line_state" type="void" visibility="0x02" properties="0x01">
    <!--${AOs::MainApp::init_line_state::ls}-->
    <parameter name="ls" type="LineState *"/>
    <!--${AOs::MainApp::init_line_state::x0}-->
    <parameter name="x0" type="int"/>
    <!--${AOs::MainApp::init_line_state::y0}-->
    <parameter name="y0" type="int"/>
    <!--${AOs::MainApp::init_line_state::x1}-->
    <parameter name="x1" type="int"/>
    <!--${AOs::MainApp::init_line_state::y1}-->
    <parameter name="y1" type="int"/>
    <code>ls-&gt;x0 = x0;
ls-&gt;x1 = x1;
ls-&gt;y0 = y0;
ls-&gt;y1 = y1;
ls-&gt;dx = abs(x1 - x0);
ls-&gt;dy = abs(y1 - y0);
ls-&gt;sx = (x0 &lt; x1) ? 1 : -1;
ls-&gt;sy = (y0 &lt; y1) ? 1 : -1;
ls-&gt;err = (ls-&gt;dx &gt; ls-&gt;dy ? ls-&gt;dx : -ls-&gt;dy) / 2;
ls-&gt;done = false;

</code>
   </operation>
   <!--${AOs::MainApp::SM}-->
   <statechart properties="0x00">
    <!--${AOs::MainApp::SM::initial}-->
    <initial target="../1">
     <initial_glyph conn="41,6,5,0,-13,6">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <!--${AOs::MainApp::SM::display}-->
    <state name="display">
     <entry>HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);</entry>
     <exit>QTimeEvt_disarm(&amp;me-&gt;tempPollEvt);
QTimeEvt_disarm(&amp;me-&gt;longPressEvt);</exit>
     <!--${AOs::MainApp::SM::display::initial}-->
     <initial target="../7">
      <initial_glyph conn="49,20,5,0,-6,5">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <!--${AOs::MainApp::SM::display::SENSOR_DONE}-->
     <tran trig="SENSOR_DONE">
      <action>//QTimeEvt_disarm(&amp;me-&gt;tempPollEvt);
//QTimeEvt_armX(&amp;me-&gt;tempPollEvt, 
//              20000U,    // Fire after 10 seconds
//              20000U);   // Then repeat every 10 seconds


SensorEvent const *sensorEvt = (SensorEvent const *)e;
printf(&quot;DONE SENSOR \n&quot;);

me-&gt;currentTemp = sensorEvt-&gt;temperature;

uint16_t tempDry = sensorEvt-&gt;dryness;
uint8_t p = MainApp_calc_dryness_percent(tempDry);
me-&gt;currentDryness = p;

if (p &gt; PLANT_DRY_THREASHOLD)
{
    static QEvt const dry_Evt = {PLANT_DRY_SIG, 0U, 0U};
    QACTIVE_POST(AO_Main_App,&amp;dry_Evt, me);
}


switch(me-&gt;currentState)
{
    case TEMPERATURE:
    display_temp(me-&gt;currentTemp);
    break;
    
    case DRYNESS:
        
        display_dry(p);
    break;
    default:
            // error
            break;

}
</action>
      <tran_glyph conn="106,38,1,-1,-22">
       <action box="-18,-3,18,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::POLL_SENSOR}-->
     <tran trig="POLL_SENSOR">
      <action>static QEvt const ADC_Start_Evt = {START_SENSOR_SIG, 0U, 0U};
printf(&quot;POLL SENSOR \n&quot;);
QACTIVE_POST(AO_Sensor,&amp;ADC_Start_Evt, me);

</action>
      <tran_glyph conn="106,33,1,-1,-22">
       <action box="-17,-3,21,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::BUTTON_PRESS}-->
     <tran trig="BUTTON_PRESS">
      <action>QTimeEvt_disarm(&amp;me-&gt;longPressEvt);
QTimeEvt_armX(&amp;me-&gt;longPressEvt, LONG_PRESS_TIME_MS / 10, 0U);
printf(&quot;pressed btn!\n&quot;);</action>
      <tran_glyph conn="106,57,1,-1,-22">
       <action box="-19,-2,18,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::BUTTON_LONG}-->
     <tran trig="BUTTON_LONG" target="../../2">
      <tran_glyph conn="53,99,2,0,16">
       <action box="0,0,22,4"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::BUTTON_RELEASE}-->
     <tran trig="BUTTON_RELEASE">
      <action brief="short press">QTimeEvt_disarm(&amp;me-&gt;longPressEvt);
printf(&quot;released btn!\n&quot;);
if(me-&gt;currentState == TEMPERATURE)
{
    me-&gt;currentState = DRYNESS;
    display_dry(me-&gt;currentDryness);
}
else
{
    me-&gt;currentState = TEMPERATURE;
    display_temp(me-&gt;currentTemp);
}</action>
      <tran_glyph conn="106,68,1,-1,-23">
       <action box="-24,-4,24,7"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::START_TETRIS}-->
     <tran trig="START_TETRIS" target="../../3">
      <action>QTimeEvt_disarm(&amp;me-&gt;tempPollEvt);
QTimeEvt_disarm(&amp;me-&gt;longPressEvt);</action>
      <tran_glyph conn="106,45,1,3,23">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::display::display_stats}-->
     <state name="display_stats">
      <entry brief="display and poll timer">display_temp(me-&gt;currentTemp);
QTimeEvt_armX(&amp;me-&gt;tempPollEvt, 
              200U,    // Fire after 10 seconds
              2000U);   // Then repeat every 10 seconds
printf(&quot;enter display stats: arm polling&quot;);</entry>
      <!--${AOs::MainApp::SM::display::display_stats::PLANT_DRY}-->
      <tran trig="PLANT_DRY" target="../../8">
       <tran_glyph conn="54,50,1,0,23,29">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="13,25,41,31">
       <entry box="0,3,6,2"/>
      </state_glyph>
     </state>
     <!--${AOs::MainApp::SM::display::dry_alert}-->
     <state name="dry_alert">
      <entry>QTimeEvt_armX(&amp;me-&gt;dryTimerEvt, DRY_TIMEOUT , 0U);
printf(&quot;entered DRY!\n&quot;);</entry>
      <exit>QTimeEvt_disarm(&amp;me-&gt;dryTimerEvt);
QTimeEvt_disarm(&amp;me-&gt;tempPollEvt);
printf(&quot;exited DRY!\n&quot;);</exit>
      <!--${AOs::MainApp::SM::display::dry_alert::WATER_PLANT}-->
      <tran trig="WATER_PLANT" target="../../../2">
       <action>QTimeEvt_disarm(&amp;me-&gt;dryTimerEvt);
QTimeEvt_armX(&amp;me-&gt;dryTimerEvt, 300U , 0U);

</action>
       <tran_glyph conn="77,90,2,1,35,-19">
        <action box="1,2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="68,79,17,11">
       <entry box="0,3,6,2"/>
       <exit box="0,5,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="9,12,97,87">
      <entry box="0,3,6,2"/>
      <exit box="0,5,6,2"/>
     </state_glyph>
    </state>
    <!--${AOs::MainApp::SM::pump}-->
    <state name="pump">
     <entry brief="ON">printf(&quot;enter pump\n&quot;);
QTimeEvt_disarm(&amp;me-&gt;longPressEvt);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);

QTimeEvt_disarm(&amp;me-&gt;dryTimerEvt);
QTimeEvt_armX(&amp;me-&gt;dryTimerEvt, 300U , 0U);

QTimeEvt_disarm(&amp;me-&gt;tempPollEvt);</entry>
     <exit brief="OFF">printf(&quot;exit pump\n&quot;);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
QTimeEvt_disarm(&amp;me-&gt;dryTimerEvt);
</exit>
     <!--${AOs::MainApp::SM::pump::BUTTON_RELEASE}-->
     <tran trig="BUTTON_RELEASE" target="../../1/7">
      <action>printf(&quot;released the btm inside pump \n&quot;);</action>
      <tran_glyph conn="38,115,0,2,-57,-1,-2">
       <action box="-17,-4,15,3"/>
      </tran_glyph>
     </tran>
     <!--${AOs::MainApp::SM::pump::WATER_PLANT}-->
     <tran trig="WATER_PLANT" target="../../1">
      <action brief="turn off pump after some time">QTimeEvt_disarm(&amp;me-&gt;dryTimerEvt);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);</action>
      <tran_glyph conn="43,115,0,2,-16">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="24,115,34,18">
      <entry box="0,3,6,2"/>
      <exit box="0,5,6,2"/>
     </state_glyph>
    </state>
    <!--${AOs::MainApp::SM::tetris}-->
    <state name="tetris">
     <!--${AOs::MainApp::SM::tetris::initial}-->
     <initial target="../1">
      <initial_glyph conn="144,31,5,0,2,7">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <!--${AOs::MainApp::SM::tetris::start_screen}-->
     <state name="start_screen">
      <entry>QTimeEvt_armX(&amp;me-&gt;dryTimerEvt, 400U , 0U);
display_tetris_logo();
</entry>
      <exit>QTimeEvt_disarm(&amp;me-&gt;dryTimerEvt);
</exit>
      <!--${AOs::MainApp::SM::tetris::start_screen::WATER_PLANT}-->
      <tran trig="WATER_PLANT" target="../../3">
       <action brief="clear">clear_board();</action>
       <tran_glyph conn="158,44,5,3,14">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="137,38,21,14">
       <entry box="0,3,6,2"/>
       <exit box="0,5,6,2"/>
      </state_glyph>
     </state>
     <!--${AOs::MainApp::SM::tetris::game}-->
     <state name="game">
      <entry>printf(&quot;entered tetris game\n&quot;);
//QTimeEvt_armX(&amp;me-&gt;tickEvt, 50U, 50U); //20 fps
QTimeEvt_armX(&amp;me-&gt;dryTimerEvt, 50U , 50U);


Tetromino t1;
Tetromino_ctor(&amp;t1, TETRO_I);
Tetromino t2;
Tetromino_ctor(&amp;t2, TETRO_O);
Board_placeTetromino( &amp;me-&gt;board_inst, &amp;t1);
draw_board(&amp;me-&gt;board_inst);
t2.y = 20;
Board_placeTetromino( &amp;me-&gt;board_inst, &amp;t2);

draw_board(&amp;me-&gt;board_inst);</entry>
      <!--${AOs::MainApp::SM::tetris::game::WATER_PLANT}-->
      <tran trig="WATER_PLANT">
       <action>//printf(&quot;tick\n&quot;);</action>
       <tran_glyph conn="276,42,1,-1,-19">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="233,28,43,60">
       <entry box="0,3,6,2"/>
      </state_glyph>
     </state>
     <!--${AOs::MainApp::SM::tetris::init_board}-->
     <state name="init_board">
      <entry>Board_init(&amp;me-&gt;board_inst);
printf(&quot;board initialized\n&quot;);
</entry>
      <!--${AOs::MainApp::SM::tetris::init_board::initial}-->
      <initial target="../1">
       <action>int w, h, x0, y0;

w = me-&gt;board_inst.width  * me-&gt;board_inst.blockSize;
h = me-&gt;board_inst.height * me-&gt;board_inst.blockSize;
x0 = me-&gt;board_inst.pos_x;
y0 = me-&gt;board_inst.pos_y;


me-&gt;line_w = w;
me-&gt;line_h = h;
me-&gt;line_x0 = x0;
me-&gt;line_y0 = y0;

static QEvt const e = {DRAW_OUTLINE_SIG, 0U, 0U};
QACTIVE_POST(AO_Main_App, &amp;e, me);</action>
       <initial_glyph conn="187,50,5,0,-4,9">
        <action box="0,-2,10,2"/>
       </initial_glyph>
      </initial>
      <!--${AOs::MainApp::SM::tetris::init_board::top_border}-->
      <state name="top_border">
       <entry>

if(!me-&gt;board_inst.rotate_90) 
{
    MainApp_init_line_state(&amp;me-&gt;line_state_inst, me-&gt;line_x0, me-&gt;line_y0, me-&gt;line_x0 + me-&gt;line_w - 1, me-&gt;line_y0);
}
else
{
    MainApp_init_line_state(
        &amp;me-&gt;line_state_inst,
        me-&gt;line_x0 + me-&gt;line_h , me-&gt;line_y0,
        me-&gt;line_x0 + me-&gt;line_h , me-&gt;line_y0 + me-&gt;line_w );
}
printf(&quot;init struct \n&quot;);

static QEvt const e = {DRAW_OUTLINE_SIG, 0U, 0U};
QACTIVE_POST(AO_Main_App, &amp;e, me);
</entry>
       <!--${AOs::MainApp::SM::tetris::init_board::top_border::DRAW_OUTLINE}-->
       <tran trig="DRAW_OUTLINE">
        <action>draw_line_step(&amp;me-&gt;line_state_inst);

</action>
        <tran_glyph conn="193,65,1,-1,-12">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <!--${AOs::MainApp::SM::tetris::init_board::top_border::DRAW_OUTLINE_DONE}-->
       <tran trig="DRAW_OUTLINE_DONE" target="../../2">
        <tran_glyph conn="183,68,2,0,8">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="173,59,20,9">
        <entry box="0,3,6,2"/>
       </state_glyph>
      </state>
      <!--${AOs::MainApp::SM::tetris::init_board::left_border}-->
      <state name="left_border">
       <entry>

//MainApp_init_line_state(&amp;me-&gt;line_state_inst,
 //                                   me-&gt;line_x0 + me-&gt;line_w - 1, me-&gt;line_y0,
//                                    me-&gt;line_x0 + me-&gt;line_w - 1, me-&gt;line_y0 + me-&gt;line_h - 1);
printf(&quot;init struct \n&quot;);
if (!me-&gt;board_inst.rotate_90) {
    // original right vertical line
    MainApp_init_line_state(
        &amp;me-&gt;line_state_inst,
        me-&gt;line_x0 + me-&gt;line_w , me-&gt;line_y0,
        me-&gt;line_x0 + me-&gt;line_w , me-&gt;line_y0 + me-&gt;line_h );
} else {
    // rotated 90° → horizontal bottom line
    MainApp_init_line_state(
        &amp;me-&gt;line_state_inst,
        me-&gt;line_x0, me-&gt;line_y0 + me-&gt;line_w,
        me-&gt;line_x0 + me-&gt;line_h, me-&gt;line_y0 + me-&gt;line_w);
}

static QEvt const e = {DRAW_OUTLINE_SIG, 0U, 0U};
QACTIVE_POST(AO_Main_App, &amp;e, me);

printf(&quot;line left: \n&quot;);
</entry>
       <!--${AOs::MainApp::SM::tetris::init_board::left_border::DRAW_OUTLINE}-->
       <tran trig="DRAW_OUTLINE">
        <action>draw_line_step(&amp;me-&gt;line_state_inst);

</action>
        <tran_glyph conn="193,81,1,-1,-12">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <!--${AOs::MainApp::SM::tetris::init_board::left_border::DRAW_OUTLINE_DONE}-->
       <tran trig="DRAW_OUTLINE_DONE" target="../../3">
        <tran_glyph conn="183,84,2,0,3">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="173,76,20,8">
        <entry box="0,3,6,2"/>
       </state_glyph>
      </state>
      <!--${AOs::MainApp::SM::tetris::init_board::btm_border}-->
      <state name="btm_border">
       <entry>

//MainApp_init_line_state(&amp;me-&gt;line_state_inst,
//                                    me-&gt;line_x0 + me-&gt;line_w -1, me-&gt;line_y0 + me-&gt;line_h - 1,
//                                    me-&gt;line_x0 , me-&gt;line_y0 + me-&gt;line_h - 1);
if (!me-&gt;board_inst.rotate_90) {
    // original bottom horizontal line
    MainApp_init_line_state(
        &amp;me-&gt;line_state_inst,
        me-&gt;line_x0 + me-&gt;line_w, me-&gt;line_y0 + me-&gt;line_h,
        me-&gt;line_x0, me-&gt;line_y0 + me-&gt;line_h);
} else {
    // rotated 90° → vertical left line
    MainApp_init_line_state(
        &amp;me-&gt;line_state_inst,
        me-&gt;line_x0, me-&gt;line_y0 + me-&gt;line_w,
        me-&gt;line_x0, me-&gt;line_y0
    );
}
static QEvt const e = {DRAW_OUTLINE_SIG, 0U, 0U};
QACTIVE_POST(AO_Main_App, &amp;e, me);

printf(&quot;line btn: \n&quot;);
</entry>
       <!--${AOs::MainApp::SM::tetris::init_board::btm_border::DRAW_OUTLINE}-->
       <tran trig="DRAW_OUTLINE">
        <action>draw_line_step(&amp;me-&gt;line_state_inst);

</action>
        <tran_glyph conn="193,92,1,-1,-12">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <!--${AOs::MainApp::SM::tetris::init_board::btm_border::DRAW_OUTLINE_DONE}-->
       <tran trig="DRAW_OUTLINE_DONE" target="../../4">
        <tran_glyph conn="183,95,2,0,6">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="173,87,20,8">
        <entry box="0,3,6,2"/>
       </state_glyph>
      </state>
      <!--${AOs::MainApp::SM::tetris::init_board::right_border}-->
      <state name="right_border">
       <entry>
if (!me-&gt;board_inst.rotate_90) {
    // original left vertical line
    MainApp_init_line_state(
        &amp;me-&gt;line_state_inst,
        me-&gt;line_x0, me-&gt;line_y0 + me-&gt;line_h,
        me-&gt;line_x0, me-&gt;line_y0
    );
} else {
    // rotated 90° → horizontal top line
    MainApp_init_line_state(
        &amp;me-&gt;line_state_inst,
        me-&gt;line_x0, me-&gt;line_y0,
        me-&gt;line_x0 + me-&gt;line_h, me-&gt;line_y0
    );
}

static QEvt const e = {DRAW_OUTLINE_SIG, 0U, 0U};
QACTIVE_POST(AO_Main_App, &amp;e, me);


printf(&quot;line right: \n&quot;);
</entry>
       <!--${AOs::MainApp::SM::tetris::init_board::right_border::DRAW_OUTLINE}-->
       <tran trig="DRAW_OUTLINE">
        <action>draw_line_step(&amp;me-&gt;line_state_inst);

</action>
        <tran_glyph conn="193,106,1,-1,-12">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <!--${AOs::MainApp::SM::tetris::init_board::right_border::DRAW_OUTLINE_DONE}-->
       <tran trig="DRAW_OUTLINE_DONE" target="../../../2">
        <action>printf(&quot;done drawing line\n&quot;);</action>
        <tran_glyph conn="183,109,2,2,2,74,-23">
         <action box="1,3,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="173,101,20,8">
        <entry box="0,3,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="172,38,22,82">
       <entry box="0,3,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="129,12,171,125"/>
    </state>
    <state_diagram size="333,204"/>
   </statechart>
  </class>
  <!--${AOs::Sensor}-->
  <class name="Sensor" superclass="qpc::QActive">
   <!--${AOs::Sensor::inst}-->
   <attribute name="inst" type="Sensor" visibility="0x02" properties="0x01"/>
   <!--${AOs::Sensor::bits[5]}-->
   <attribute name="bits[5]" type="uint8_t" visibility="0x00" properties="0x00"/>
   <!--${AOs::Sensor::bit_index}-->
   <attribute name="bit_index" type="uint8_t" visibility="0x00" properties="0x00"/>
   <!--${AOs::Sensor::byte_index}-->
   <attribute name="byte_index" type="uint8_t" visibility="0x00" properties="0x00"/>
   <!--${AOs::Sensor::reading_high}-->
   <attribute name="reading_high" type="bool" visibility="0x02" properties="0x00"/>
   <!--${AOs::Sensor::pulse_count}-->
   <attribute name="pulse_count" type="uint8_t" visibility="0x02" properties="0x00"/>
   <!--${AOs::Sensor::dma_buffer}-->
   <attribute name="dma_buffer" type="volatile uint32_t*" visibility="0x02" properties="0x00"/>
   <!--${AOs::Sensor::dma_index}-->
   <attribute name="dma_index" type="uint8_t" visibility="0x02" properties="0x00">
    <code>= 0;</code>
   </attribute>
   <!--${AOs::Sensor::resetEvt}-->
   <attribute name="resetEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::Sensor::dht11StartEvt}-->
   <attribute name="dht11StartEvt" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <!--${AOs::Sensor::get_adc_dryness}-->
   <operation name="get_adc_dryness" type="uint16_t" visibility="0x02" properties="0x01">
    <code>/*
// Start ADC conversion
HAL_ADC_Start(&amp;hadc1);

// Wait for conversion to complete
if (HAL_ADC_PollForConversion(&amp;hadc1, 10) == HAL_OK) { // timeout in ms
    // Read the converted value
    return (uint16_t)HAL_ADC_GetValue(&amp;hadc1);
}

return 0;
*/


LL_ADC_REG_StartConversion(ADC1);

// Wait for conversion to complete
while(!LL_ADC_IsActiveFlag_EOC(ADC1));

// Read ADC value
uint16_t adc_value = LL_ADC_REG_ReadConversionData12(ADC1);

// Clear end-of-conversion flag (optional, sometimes auto-cleared)
LL_ADC_ClearFlag_EOC(ADC1);

return adc_value;</code>
   </operation>
   <!--${AOs::Sensor::SM}-->
   <statechart properties="0x00">
    <!--${AOs::Sensor::SM::initial}-->
    <initial target="../1">
     <initial_glyph conn="60,16,4,0,15">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <!--${AOs::Sensor::SM::waiting}-->
    <state name="waiting">
     <entry>printf(&quot;1 waiting waiting \n&quot;);
QTimeEvt_disarm(&amp;me-&gt;resetEvt);
</entry>
     <!--${AOs::Sensor::SM::waiting::START_SENSOR}-->
     <tran trig="START_SENSOR" target="../../3">
      <tran_glyph conn="76,62,4,0,13">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="42,31,70,31">
      <entry box="0,3,6,2"/>
     </state_glyph>
    </state>
    <!--${AOs::Sensor::SM::wait_response}-->
    <state name="wait_response">
     <entry>//printf(&quot;4 entry to waiting for responce\n&quot;);
me-&gt;bit_index = 0;
me-&gt;byte_index = 0;
me-&gt;reading_high = true;
me-&gt;pulse_count = 0; 
memset(me-&gt;bits, 0, sizeof(me-&gt;bits));
</entry>
     <!--${AOs::Sensor::SM::wait_response::DHT11_RESET}-->
     <tran trig="DHT11_RESET" target="../../1">
      <action>QTimeEvt_disarm(&amp;me-&gt;resetEvt);
printf(&quot;Reset DHT11&quot;);</action>
      <tran_glyph conn="100,93,0,2,-31">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <!--${AOs::Sensor::SM::wait_response::DHT11_TIMER_IC}-->
     <tran trig="DHT11_TIMER_IC" target="../../1">
      <action>uint32_t localTimestamps[TIMESTAMP_SIZE];
BSP_get_timestamps(localTimestamps);

for(uint8_t i = 0; i &lt; TIMESTAMP_SIZE; i++)
{
    if(i &lt; 3) { continue; } // ignore ack, start

    if (i % 2 == 1) { // positive edge (HIGH pulse duration)
        // Determine if the current HIGH pulse represents a '1' or '0'
        uint8_t bit_val = (localTimestamps[i] &gt; 40) ? 1 : 0;  // FIXED!

        // Store bit in the main bits array
        if (bit_val) {
            me-&gt;bits[me-&gt;byte_index] |= (1 &lt;&lt; (7 - me-&gt;bit_index));
        } else {
            me-&gt;bits[me-&gt;byte_index] &amp;= ~(1 &lt;&lt; (7 - me-&gt;bit_index));
        }

        // Move to next bit
        me-&gt;bit_index++;

        // If a byte is complete, move to next byte
        if (me-&gt;bit_index &gt; 7) {
            me-&gt;bit_index = 0;
            me-&gt;byte_index++;

            // If 5 bytes (40 bits) are read, finalize
            if (me-&gt;byte_index &gt;= 5) {
                // Verify checksum
                uint8_t checksum = me-&gt;bits[0] + me-&gt;bits[1] + me-&gt;bits[2] + me-&gt;bits[3];
                printf(&quot;5 sending data&quot;);
                if (checksum == me-&gt;bits[4]) {
                    uint16_t dryness_val = Sensor_get_adc_dryness();

                    SensorEvent *evt = Q_NEW(SensorEvent, SENSOR_DONE_SIG);
                    evt-&gt;dryness = dryness_val;
                    evt-&gt;temperature = me-&gt;bits[2];

                    QACTIVE_POST(AO_Main_App, &amp;evt-&gt;super, NULL);
                    status_ = Q_TRAN(&amp;Sensor_waiting);
                    break;


                } else {
                    printf(&quot;Checksum error! Expected: %u, Got: %u\n&quot;,
                           checksum, me-&gt;bits[4]);
                }

                // Reset or go to waiting state
                //status_ = Q_TRAN(&amp;Sensor_waiting);
                break;
            }
        }
    } // ADDED: Close the if (i % 2 == 0) block
}



</action>
      <tran_glyph conn="48,120,3,2,-3,-58">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="48,93,65,45">
      <entry box="0,3,6,2"/>
     </state_glyph>
    </state>
    <!--${AOs::Sensor::SM::start_dht}-->
    <state name="start_dht">
     <entry>//printf(&quot;2 start DHT arm 30ms \n&quot;);
for(int i=0;i&lt;5;i++) me-&gt;bits[i]=0;
me-&gt;bit_index = 0;
me-&gt;byte_index = 0;

QTimeEvt_armX(&amp;me-&gt;resetEvt, DHT11_RESET_TIME, 0U);


// Pull DHT11 LOW ≥18ms
DHT11_SetPinOutput();
HAL_GPIO_WritePin(DHT11_PORT, DHT11_PIN, GPIO_PIN_RESET);
QTimeEvt_armX(&amp;me-&gt;dht11StartEvt, 2U, 0U); // 27ms</entry>
     <!--${AOs::Sensor::SM::start_dht::DHT11_START}-->
     <tran trig="DHT11_START" target="../../2">
      <action>//printf(&quot;3 transition to input \n&quot;);
DHT11_SetPinInput();
Delay_us(30);  // 20–40 µs wait</action>
      <tran_glyph conn="76,83,2,0,10">
       <action box="1,1,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="71,75,11,8">
      <entry box="0,3,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="196,261"/>
   </statechart>
  </class>
  <!--${AOs::RFButton}-->
  <class name="RFButton" superclass="qpc::QActive">
   <!--${AOs::RFButton::inst}-->
   <attribute name="inst" type="RFButton" visibility="0x02" properties="0x01"/>
   <!--${AOs::RFButton::receive_rf}-->
   <operation name="receive_rf" type="void" visibility="0x02" properties="0x01">
    <code>while(nrf24_data_available()) {
        uint8_t payload[PLD_S]; 
        nrf24_receive(payload, sizeof(payload));

        if(payload[0] == 49U)
        {
            static QEvt const nrfEvt = { BUTTON_PRESS_SIG, 0U, 0U };
            QACTIVE_POST(AO_Main_App, &amp;nrfEvt, me);
        }

        if(payload[0] == 50U)
        {
            static QEvt const rlsEvt = { BUTTON_RELEASE_SIG, 0U, 0U };
            QACTIVE_POST(AO_Main_App, &amp;rlsEvt, me);
        }
        
    }</code>
   </operation>
   <!--${AOs::RFButton::SM}-->
   <statechart properties="0x00">
    <!--${AOs::RFButton::SM::initial}-->
    <initial target="../1">
     <initial_glyph conn="49,9,5,0,-6,10">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <!--${AOs::RFButton::SM::wait}-->
    <state name="wait">
     <entry>printf(&quot;wait\n&quot;);
</entry>
     <!--${AOs::RFButton::SM::wait::NRF_IRQ}-->
     <tran trig="NRF_IRQ">
      <action brief="receive">RFButton_receive_rf();
</action>
      <tran_glyph conn="41,36,4,-1,-9">
       <action box="1,-3,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="26,19,32,17">
      <entry box="0,3,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="153,121"/>
   </statechart>
  </class>
 </package>
 <!--${Inc}-->
 <directory name="Inc">
  <!--${Inc::main_app.h}-->
  <file name="main_app.h">
   <text>#ifndef MAIN_APP_H
#define MAIN_APP_H

#include &quot;qpc.h&quot;
#include &quot;temp_sensor.h&quot;
#include &quot;display.h&quot;
#include &quot;plant_sensor.h&quot;
#include &quot;sensor.h&quot;
#include &quot;rfbutton.h&quot;
#include &quot;tetris_board.h&quot;
#include &quot;tetromino.h&quot;

//keep track of substates
typedef enum {
    TEMPERATURE,
    DRYNESS
} display_states;

$declare${AOs::MainApp}

$declare ${Shared}
// Signals
enum MenuGameSignals {
    BUTTON_PRESS_SIG = Q_USER_SIG,
    POLL_SENSOR_SIG,
    BUTTON_SHORT_SIG,
    BUTTON_LONG_SIG,
    BUTTON_RELEASE_SIG,
    START_SENSOR_SIG,
    SENSOR_DONE_SIG,
    NRF_IRQ_SIG,
    DHT11_START_SIG,
    DHT11_TIMER_IC_SIG,
    DHT11_RESET_SIG,
    DHT11_DONE_SIG,
    PLANT_DRY_SIG,
    WATER_PLANT_SIG,
    START_TETRIS_SIG,
    DRAW_OUTLINE_SIG,
    DRAW_OUTLINE_DONE_SIG,
    TICK_SIG,
    MAX_SIG  
};


//events

typedef struct {
    QEvt super;       
    uint16_t dryness;      
    uint16_t temperature;    
} SensorEvent;

/*
typedef struct {
    QEvt super;      
    uint32_t pulse_length_timestamps[TIMESTAMP_SIZE]; 
} DHT11Evt;
*/
#endif </text>
  </file>
  <!--${Inc::sensor.h}-->
  <file name="sensor.h">
   <text>#ifndef SENSOR_H
#define SENSOR_H

#include &quot;qpc.h&quot;

$declare${AOs::Sensor}


#endif </text>
  </file>
  <!--${Inc::rfbutton.h}-->
  <file name="rfbutton.h">
   <text>#ifndef RFBUTTON_H
#define RFBUTTON_H

#include &quot;qpc.h&quot;

$declare${AOs::RFButton}



#endif </text>
  </file>
 </directory>
 <!--${Src}-->
 <directory name="Src">
  <!--${Src::main_app.c}-->
  <file name="main_app.c">
   <text>

#include &quot;main_app.h&quot;
#include &lt;stdio.h&gt;
#include &quot;app_config.h&quot;
#include &quot;NRF_chip.h&quot;
#include &quot;main.h&quot;;

//DMA buffer
static __attribute__((section(&quot;.bss&quot;))) __attribute__((aligned(4))) volatile uint32_t Sensor_dht11_dma_buffer[DHT11_MAX_EDGES];
static uint8_t gridArray[200];

$define${AOs::MainApp}
$define${Shared}


</text>
  </file>
  <!--${Src::sensor.c}-->
  <file name="sensor.c">
   <text>#include &quot;sensor.h&quot;
#include &lt;stdio.h&gt;
#include &quot;main_app.h&quot;
#include &quot;app_config.h&quot;
#include &quot;temp_sensor.h&quot;
#include &quot;stm32c0xx_ll_adc.h&quot;
//extern ADC_HandleTypeDef hadc1;
//extern TIM_HandleTypeDef htim3;
//extern DMA_HandleTypeDef hdma;
//extern DMA_HandleTypeDef hdma_tim3_ch1;
$define${AOs::Sensor}



// DMA buffer must be in RAM, not flash
// Must be in RAM for DMA, do NOT use 'const'
//static __attribute__((aligned(4))) volatile uint32_t dht11_dma_buffer[DHT11_MAX_EDGES];
//static volatile uint8_t dma_index = 0;

//QActive * const AO_Sensor = &amp;Sensor_inst;</text>
  </file>
  <!--${Src::rfbutton.c}-->
  <file name="rfbutton.c">
   <text>#include &quot;rfbutton.h&quot;
#include &quot;main_app.h&quot;
#include &quot;NRF_chip.h&quot;
$define${AOs::RFButton}</text>
  </file>
 </directory>
</model>
